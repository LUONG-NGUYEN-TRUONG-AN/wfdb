#include "performance_metrics.h"
#include "symbolic_dynamic.h" // For ensure_gen_directory

/**
 * Initialize performance metrics structure
 * @param metrics: Pointer to performance metrics structure
 */
void performance_metrics_init(performance_metrics_t *metrics) {
    if (!metrics) {
        fprintf(stderr, "performance_metrics_init: Invalid input parameter\n");
        return;
    }
    
    metrics->TP = 0;
    metrics->FP = 0;
    metrics->FN = 0;
    metrics->TN = 0;
    metrics->Se = 0;
    metrics->Sp = 0;
    metrics->PPV = 0;
    metrics->ACC = 0;
}

/**
 * Update confusion matrix with new predictions
 * @param metrics: Pointer to performance metrics structure
 * @param actual: Array of actual labels (0 or 1)
 * @param predicted: Array of predicted labels (0 or 1)
 * @param length: Length of arrays
 */
void performance_metrics_update(performance_metrics_t *metrics, const uint8_t *actual, const int8_t *predicted, size_t length) {
    if (!metrics || !actual || !predicted || length == 0) {
        fprintf(stderr, "performance_metrics_update: Invalid input parameters\n");
        return;
    }
    
    for (size_t i = 0; i < length; i++) {
        if ((actual[i] == 1) && (predicted[i] == 1)) {
            metrics->TP++;
        } else if ((actual[i] == 0) && (predicted[i] == 1)) {
            metrics->FP++;
        } else if ((actual[i] == 1) && (predicted[i] == 0)) {
            metrics->FN++;
        } else if ((actual[i] == 0) && (predicted[i] == 0)) {
            metrics->TN++;
        }
    }
}

/**
 * Calculate performance metrics from confusion matrix
 * @param metrics: Pointer to performance metrics structure
 */
void performance_metrics_calculate(performance_metrics_t *metrics) {
    if (!metrics) {
        fprintf(stderr, "performance_metrics_calculate: Invalid input parameter\n");
        return;
    }
    
    // Calculate performance metrics with division by zero protection
    metrics->Se = (metrics->TP + metrics->FN > 0) ? (metrics->TP * 100) / (metrics->TP + metrics->FN) : 0;
    metrics->Sp = (metrics->TN + metrics->FP > 0) ? (metrics->TN * 100) / (metrics->TN + metrics->FP) : 0;
    metrics->PPV = (metrics->TP + metrics->FP > 0) ? (metrics->TP * 100) / (metrics->TP + metrics->FP) : 0;
    metrics->ACC = (metrics->TP + metrics->TN + metrics->FP + metrics->FN > 0) ? 
                   ((metrics->TP + metrics->TN) * 100) / (metrics->TP + metrics->TN + metrics->FP + metrics->FN) : 0;
}

/**
 * Print performance metrics to console
 * @param metrics: Pointer to performance metrics structure
 * @param record_name: Name of the record
 */
void performance_metrics_print(const performance_metrics_t *metrics, const char *record_name) {
    if (!metrics || !record_name) {
        fprintf(stderr, "performance_metrics_print: Invalid input parameters\n");
        return;
    }
    printf("Record: %s TP: %lld, FP: %lld, FN: %lld, TN: %lld\n", record_name, metrics->TP, metrics->FP, metrics->FN, metrics->TN);
    printf("Sensitivity (Se): %lld%%, Specificity (Sp): %lld%%, PPV: %lld%%, Accuracy: %lld%%\n",
           metrics->Se, metrics->Sp, metrics->PPV, metrics->ACC);
}

/**
 * Write performance metrics to file
 * @param metrics: Pointer to performance metrics structure
 * @param record_name: Name of the record
 */
void performance_metrics_write_to_file(const performance_metrics_t *metrics, const char *record_name) {
    if (!metrics || !record_name) {
        fprintf(stderr, "performance_metrics_write_to_file: Invalid input parameters\n");
        return;
    }
    
    ensure_gen_directory();
    FILE *file = fopen("gen/result.txt", "a"); // Append mode to accumulate results from multiple records
    if (file) {
        fprintf(file, "Record: %s\n", record_name);
        fprintf(file, "TP: %lld, FP: %lld, FN: %lld, TN: %lld\n", 
               metrics->TP, metrics->FP, metrics->FN, metrics->TN);
        fprintf(file, "Sensitivity (Se): %lld%%, Specificity (Sp): %lld%%, PPV: %lld%%, Accuracy: %lld%%\n",
               metrics->Se, metrics->Sp, metrics->PPV, metrics->ACC);
        fprintf(file, "-------------------------------------------\n");
        fflush(file);
        fclose(file);
    } else {
        fprintf(stderr, "Error: Could not open result.txt for writing\n");
    }
}

/**
 * Reset/clear the results file at the beginning of a new project run
 */
void performance_metrics_reset_file(void) {
    ensure_gen_directory();
    
    // Reset text results file
    FILE *file = fopen("gen/result.txt", "w"); // Write mode to truncate/reset file
    if (file) {
        fprintf(file, "=== Performance Metrics Results ===\n");
        fprintf(file, "Generated by WFDB Signal Processing Project\n");
        fprintf(file, "========================================\n\n");
        fflush(file);
        fclose(file);
        printf("Results file reset successfully.\n");
    } else {
        fprintf(stderr, "Warning: Could not reset result.txt file\n");
    }
    
    // Reset CSV file
    FILE *csv_file = fopen("gen/performance_metrics.csv", "w");
    if (csv_file) {
        fclose(csv_file); // Just create/truncate the file, header will be written by first record
        printf("CSV file reset successfully.\n");
    } else {
        fprintf(stderr, "Warning: Could not reset performance_metrics.csv file\n");
    }
}

/**
 * Write average performance metrics across all records to file
 * @param total_metrics: Array of performance metrics for all records
 * @param num_records: Number of records processed
 */
void performance_metrics_write_averages(const performance_metrics_t *total_metrics, size_t num_records) {
    if (!total_metrics || num_records == 0) {
        fprintf(stderr, "performance_metrics_write_averages: Invalid input parameters\n");
        return;
    }
    
    // Calculate averages
    WFDB_Time avg_Se = 0, avg_Sp = 0, avg_PPV = 0, avg_ACC = 0;
    WFDB_Time valid_Se = 0, valid_Sp = 0, valid_PPV = 0, valid_ACC = 0;
    
    for (size_t i = 0; i < num_records; i++) {
        // Only include records that have valid metrics (avoid division by zero cases)
        if (total_metrics[i].Se > 0 || (total_metrics[i].TP + total_metrics[i].FN > 0)) {
            avg_Se += total_metrics[i].Se;
            valid_Se++;
        }
        if (total_metrics[i].Sp > 0 || (total_metrics[i].TN + total_metrics[i].FP > 0)) {
            avg_Sp += total_metrics[i].Sp;
            valid_Sp++;
        }
        if (total_metrics[i].PPV > 0 || (total_metrics[i].TP + total_metrics[i].FP > 0)) {
            avg_PPV += total_metrics[i].PPV;
            valid_PPV++;
        }
        if (total_metrics[i].ACC > 0 || (total_metrics[i].TP + total_metrics[i].TN + total_metrics[i].FP + total_metrics[i].FN > 0)) {
            avg_ACC += total_metrics[i].ACC;
            valid_ACC++;
        }
    }
    
    // Calculate final averages
    avg_Se = (valid_Se > 0) ? avg_Se / valid_Se : 0;
    avg_Sp = (valid_Sp > 0) ? avg_Sp / valid_Sp : 0;
    avg_PPV = (valid_PPV > 0) ? avg_PPV / valid_PPV : 0;
    avg_ACC = (valid_ACC > 0) ? avg_ACC / valid_ACC : 0;
    
    ensure_gen_directory();
    FILE *file = fopen("gen/result.txt", "a"); // Append mode
    if (file) {
        fprintf(file, "Average Sensitivity (Se): %lld%%\n", avg_Se);
        fprintf(file, "Average Specificity (Sp): %lld%%\n", avg_Sp);
        fprintf(file, "Average PPV: %lld%%\n", avg_PPV);
        fprintf(file, "Average Accuracy: %lld%%\n", avg_ACC);
        fprintf(file, "=====================================\n");
        fflush(file);
        fclose(file);
        
        // Also print to console
        printf("Average Sensitivity (Se): %lld%%\n", avg_Se);
        printf("Average Specificity (Sp): %lld%%\n", avg_Sp);
        printf("Average PPV: %lld%%\n", avg_PPV);
        printf("Average Accuracy: %lld%%\n", avg_ACC);
        printf("=====================================\n");
        
        // Also append averages to CSV file
        FILE *csv_file = fopen("gen/performance_metrics.csv", "a");
        if (csv_file) {
            fprintf(csv_file, "AVERAGE,,,,,,%lld,%lld,%lld,%lld\n", avg_Se, avg_Sp, avg_PPV, avg_ACC);
            fflush(csv_file);
            fclose(csv_file);
        }
    } else {
        fprintf(stderr, "Error: Could not open result.txt for writing averages\n");
    }
}

/**
 * Export performance metrics to CSV file
 * @param metrics: Pointer to performance metrics structure
 * @param record_name: Name of the record
 */
void export_metrics_to_csv(const performance_metrics_t *metrics, const char *record_name) {
    if (!metrics || !record_name) {
        fprintf(stderr, "export_metrics_to_csv: Invalid input parameters\n");
        return;
    }
    
    ensure_gen_directory();
    
    // Check if CSV file exists to determine if we need to write header
    FILE *check_file = fopen("gen/performance_metrics.csv", "r");
    int write_header = (check_file == NULL);
    if (check_file) fclose(check_file);
    
    FILE *file = fopen("gen/performance_metrics.csv", "a"); // Append mode
    if (file) {
        // Write header if this is the first record
        if (write_header) {
            fprintf(file, "Record,TP,FP,FN,TN,Se,Sp,PPV,ACC\n");
        }
        
        // Write metrics data
        fprintf(file, "%s,%lld,%lld,%lld,%lld,%lld,%lld,%lld,%lld\n",
                record_name, metrics->TP, metrics->FP, metrics->FN, metrics->TN,
                metrics->Se, metrics->Sp, metrics->PPV, metrics->ACC);
        
        fflush(file);
        fclose(file);
        
        printf("Metrics exported to gen/performance_metrics.csv\n");
    } else {
        fprintf(stderr, "Error: Could not open gen/performance_metrics.csv for writing\n");
    }
}

/**
 * Export actual vs predicted labels to text file for comparison
 * @param actual: Array of actual labels (0 or 1)
 * @param predicted: Array of predicted labels (0 or 1) 
 * @param length: Length of arrays
 * @param record_name: Name of the record
 */
void export_comparison_to_file(const uint8_t *actual, const int8_t *predicted, const char *record_name, rr_intervals_t *rr_intervals) {
    if (!actual || !predicted || !record_name || !rr_intervals) {
        fprintf(stderr, "export_comparison_to_file: Invalid input parameters\n");
        return;
    }
    
    ensure_gen_directory();
    char filename[256];
    snprintf(filename, sizeof(filename), "gen/comparison_%s.txt", record_name);
    
    FILE *file = fopen(filename, "w");
    if (file) {
        // Write header with fixed-width columns
        fprintf(file, "# Record: %s\n", record_name);
        fprintf(file, "# %-10s %-10s %-10s %-10s\n", "Index", "Type", "Actual", "Predicted");
        fprintf(file, "# ---------- ---------- ---------- ----------\n");

        // Write data with fixed-width formatting
        for (size_t i = 0; i < rr_intervals->length; i++) {
            uint8_t predicted_u8 = (uint8_t)predicted[i];
            fprintf(file, "%-10s %-10s %-10u %-10u\n", mstimstr(-rr_intervals->time[i]), annstr(rr_intervals->type[i]), actual[i], predicted_u8);
        }
        
        fflush(file);
        fclose(file);
    } else {
        fprintf(stderr, "Error: Could not open %s for writing\n", filename);
    }
}
